<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Almost Square Contours Detection</title>
  <script src="https://docs.opencv.org/4.5.4/opencv.js"></script>
</head>
<body>
  <h1>Almost Square Contours Detection</h1>
  <video id="videoElement" width="640" height="480" autoplay></video>
  <canvas id="canvasOutput" width="640" height="480"></canvas>
  <button id="captureButton">Capture Image</button>
  <div id="capturedImage"></div>

  <script>
    const video = document.getElementById('videoElement');
    const canvas = document.getElementById('canvasOutput');
    const ctx = canvas.getContext('2d');
    const captureButton = document.getElementById('captureButton');
    const capturedImageDiv = document.getElementById('capturedImage');
    let frameCapture = null;

    // Load OpenCV.js
    cv.onRuntimeInitialized = () => {
      startVideo();
    };

    // Function to start capturing video
    function startVideo() {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then((stream) => {
          video.srcObject = stream;
          video.play();
          processVideo();
        })
        .catch((err) => {
          console.error("Error accessing the webcam: " + err);
        });
    }

    // Function to process video frames
    function processVideo() {
      let cap = new cv.VideoCapture(video);
      setInterval(() => {
        let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        cap.read(frame);

        let gray = new cv.Mat();
        cv.cvtColor(frame, gray, cv.COLOR_RGBA2GRAY);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // Find almost square contours
        for (let i = 0; i < contours.size(); i++) {
          let contour = contours.get(i);
          let perimeter = cv.arcLength(contour, true);
          let approx = new cv.Mat();
          cv.approxPolyDP(contour, approx, 0.03 * perimeter, true);

          if (approx.rows === 4) {
            let area = cv.contourArea(approx);
            let boundingRect = cv.boundingRect(approx);
            let aspectRatio = boundingRect.width / boundingRect.height;
            if (aspectRatio >= 0.9 && aspectRatio <= 1.1) {
              // Draw the contour
              let contoursColor = new cv.Scalar(255, 0, 0, 255);
              cv.drawContours(frame, contours, i, contoursColor, 2, cv.LINE_8, hierarchy, 0);
            }
          }
          approx.delete();
        }

        cv.imshow('canvasOutput', frame);
        frameCapture = frame.clone(); // Save the frame for capture
        frame.delete();
        gray.delete();
        contours.delete();
        hierarchy.delete();
      }, 100);
    }

    // Function to capture and display the image
    captureButton.addEventListener('click', () => {
      if (frameCapture !== null) {
        let dataURL = canvas.toDataURL(); // Convert canvas to data URL
        let img = document.createElement('img');
        img.src = dataURL;
        capturedImageDiv.innerHTML = ''; // Clear previous images
        capturedImageDiv.appendChild(img);
      }
    });
  </script>
</body>
</html>
