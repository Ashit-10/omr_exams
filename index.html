<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shape Detection and Contours</title>
  <script src="https://docs.opencv.org/4.5.4/opencv.js"></script>
</head>
<body>
  <h1>Shape Detection and Contours</h1>
  <video id="videoElement" width="140" height="180" muted playsinline loop autoplay controls></video>
  <canvas id="canvasOutput" width="140" height="180"></canvas>
  <button id="captureButton">Capture Image</button>
  <div id="capturedImage"></div>

  <script>
    const video = document.getElementById('videoElement');
    const canvas = document.getElementById('canvasOutput');
    const ctx = canvas.getContext('2d');
    const captureButton = document.getElementById('captureButton');
    const capturedImageDiv = document.getElementById('capturedImage');
    let frameCapture = null;

    // Load OpenCV.js
    cv.onRuntimeInitialized = () => {
      startVideo();
    };

    // Function to start capturing video from back camera
    function startVideo() {
      navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }) // Specify facingMode
        .then((stream) => {
          video.srcObject = stream;
          video.play();
          processVideo();
        })
        .catch((err) => {
          console.error("Error accessing the back camera: " + err);
        });
    }

    // Function to process video frames
    function processVideo() {
      let cap = new cv.VideoCapture(video);
      setInterval(() => {
        let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        cap.read(frame);

        let gray = new cv.Mat();
        cv.cvtColor(frame, gray, cv.COLOR_RGBA2GRAY);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // Draw contours for different shapes
        for (let i = 0; i < contours.size(); i++) {
          let contour = contours.get(i);
          let area = cv.contourArea(contour);
          let perimeter = cv.arcLength(contour, true);
          let approx = new cv.Mat();
          cv.approxPolyDP(contour, approx, 0.03 * perimeter, true);

          if (area > 100) {
            let shapeType;
            let vertices = approx.rows;
            if (vertices === 3) {
              shapeType = "Triangle";
            } else if (vertices === 4) {
              let boundingRect = cv.boundingRect(approx);
              let aspectRatio = boundingRect.width / boundingRect.height;
              if (aspectRatio >= 0.9 && aspectRatio <= 1.1) {
                shapeType = "Square";
              } else {
                shapeType = "Rectangle";
              }
            } else if (vertices > 6) {
              shapeType = "Circle";
            }

            // Draw contours based on shape type
            let contoursColor = new cv.Scalar(0, 255, 0, 255); // Green color
            cv.drawContours(frame, contours, i, contoursColor, 2, cv.LINE_8, hierarchy, 0);
            cv.putText(frame, shapeType, new cv.Point(approx.data32S[0], approx.data32S[1]), cv.FONT_HERSHEY_SIMPLEX, 0.5, contoursColor, 2);
          }
          approx.delete();
        }

        cv.imshow('canvasOutput', frame);
        frameCapture = frame.clone(); // Save the frame for capture
        frame.delete();
        gray.delete();
        contours.delete();
        hierarchy.delete();
      }, 100);
    }

    // Function to capture and display the image
    captureButton.addEventListener('click', () => {
      if (frameCapture !== null) {
        let dataURL = canvas.toDataURL(); // Convert canvas to data URL
        let img = new Image();
        img.src = dataURL;
        img.onload = function() {
          ctx.drawImage(img, 0, 0);
          let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          let contours = new cv.MatVector();
          let hierarchy = new cv.Mat();
          cv.findContours(imageData, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
          for (let i = 0; i < contours.size(); i++) {
            let contoursColor = new cv.Scalar(0, 255, 0, 255); // Green color
            cv.drawContours(imageData, contours, i, contoursColor, 2, cv.LINE_8, hierarchy, 0);
          }
          cv.imshow('canvasOutput', imageData);
          contours.delete();
          hierarchy.delete();
        };
        capturedImageDiv.innerHTML = ''; // Clear previous images
        capturedImageDiv.appendChild(img);
      }
    });
  </script>
</body>
</html>
