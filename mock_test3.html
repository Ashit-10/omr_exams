<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pro Online Test System</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<style>
body { background-color: #fff; overflow-x: hidden; touch-action: none; }
.test-container { padding: 20px; position: relative; min-height: 100vh; }
.question-box { border: 1px solid #ddd; border-radius: 12px; padding: 20px; background-color: #fafafa; position: relative; z-index: 1; box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
.option-label { display: flex; padding: 14px; border: 2px solid #ddd; border-radius: 8px; cursor: pointer; margin-bottom: 12px; background: white; transition: 0.2s; }
.options input[type="radio"] { display: none; }

/* Fixed Controls - Higher Z-Index */
.controls-overlay {
  position: sticky; top: 10px; z-index: 2000; 
  background: white; padding: 12px; border-radius: 10px; border: 1px solid #dee2e6;
}

#notification {
  position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
  padding: 10px 25px; color: white; display: none; font-weight: bold; z-index: 3000; border-radius: 50px;
}
.correct { background: #28a745; }
.incorrect { background: #dc3545; }

/* Canvas Layer */
#drawing-canvas {
  position: absolute; top: 0; left: 0;
  pointer-events: none; z-index: 500;
  image-rendering: auto; /* Ensures smooth crisp lines */
}
.canvas-active { pointer-events: auto !important; }

.tool-active { border: 2px solid #000 !important; background-color: #e9ecef !important; }
</style>
</head>

<body>

<div class="test-container" id="main-container">
  <canvas id="drawing-canvas"></canvas>

  <div class="controls-overlay shadow mb-4">
    <div class="d-flex flex-wrap align-items-center gap-2">
        <button id="pen-btn" class="btn btn-outline-dark btn-sm" onclick="setTool('pen')">Pen: OFF</button>
        <button id="eraser-btn" class="btn btn-outline-secondary btn-sm" onclick="setTool('eraser')">Eraser</button>
        <button class="btn btn-danger btn-sm" onclick="clearCanvas()">Clear All</button>
        
        <div class="vr mx-2"></div>

        <input type="color" id="pen-color" value="#0000ff" class="form-control form-control-color form-control-sm border-0">
        
        <div class="d-flex align-items-center gap-2">
            <span class="small fw-bold">Size:</span>
            <input type="range" id="pen-size" min="1" max="20" value="3" class="form-range" style="width:80px;">
        </div>

        <div class="ms-auto">
            <span id="score-banner" class="badge bg-primary fs-6">Score: 0</span>
        </div>
    </div>
  </div>

  <div id="questions-container"></div>

  <div class="d-flex justify-content-between mt-4 pb-5">
    <button class="btn btn-outline-secondary px-4" onclick="prevQuestion()">Previous</button>
    <button class="btn btn-primary px-5 fw-bold" onclick="nextQuestion()">Next</button>
  </div>
</div>

<div id="notification"></div>

<script>
let questions = [];
let score = 0;
let currentQuestionIndex = 0;

const canvas = document.getElementById('drawing-canvas');
const ctx = canvas.getContext('2d');
let drawing = false;
let currentTool = 'off'; // 'off', 'pen', 'eraser'

// High-DPI Resolution Setup (Ultra Clear Strokes)
function setupCanvas() {
    const rect = document.getElementById('main-container').getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    
    // Set display size
    canvas.style.width = document.documentElement.scrollWidth + 'px';
    canvas.style.height = document.documentElement.scrollHeight + 'px';
    
    // Set actual internal resolution
    canvas.width = document.documentElement.scrollWidth * dpr;
    canvas.height = document.documentElement.scrollHeight * dpr;
    
    // Scale context to match DPR
    ctx.scale(dpr, dpr);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
}

function setTool(tool) {
    const penBtn = document.getElementById('pen-btn');
    const eraserBtn = document.getElementById('eraser-btn');
    
    if (tool === 'pen') {
        if (currentTool === 'pen') {
            currentTool = 'off';
            penBtn.innerText = "Pen: OFF";
            penBtn.classList.remove('btn-dark');
            canvas.classList.remove('canvas-active');
        } else {
            currentTool = 'pen';
            penBtn.innerText = "Pen: ON";
            penBtn.classList.add('btn-dark');
            eraserBtn.classList.remove('tool-active');
            canvas.classList.add('canvas-active');
        }
    } else if (tool === 'eraser') {
        currentTool = 'eraser';
        canvas.classList.add('canvas-active');
        eraserBtn.classList.add('tool-active');
        penBtn.classList.remove('btn-dark');
        penBtn.innerText = "Pen: OFF";
    }
}

function clearCanvas() {
    const dpr = window.devicePixelRatio || 1;
    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
}

// Coordinate Handling
function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
    return {
        x: clientX + window.scrollX,
        y: clientY + window.scrollY
    };
}

function startDrawing(e) {
    if(currentTool === 'off') return;
    drawing = true;
    const pos = getPos(e);
    ctx.beginPath();
    
    if (currentTool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = document.getElementById('pen-size').value * 4; // Eraser a bit bigger
    } else {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = document.getElementById('pen-color').value;
        ctx.lineWidth = document.getElementById('pen-size').value;
    }
    
    ctx.moveTo(pos.x, pos.y);
}

function draw(e) {
    if (!drawing || currentTool === 'off') return;
    const pos = getPos(e);
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
}

function stopDrawing() { 
    drawing = false; 
    ctx.closePath();
}

canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
window.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('touchstart', (e) => { startDrawing(e); e.preventDefault(); }, {passive: false});
canvas.addEventListener('touchmove', (e) => { draw(e); e.preventDefault(); }, {passive: false});
canvas.addEventListener('touchend', stopDrawing);

// ---------- CORE LOGIC ----------
const urlParams = new URLSearchParams(window.location.search);
const fileLoc = urlParams.get('file');

fetch(fileLoc + "/question.txt")
.then(r => r.text())
.then(qText => fetch(fileLoc + "/answer.txt").then(r => r.json()).then(ans => ({qText, ans})))
.then(({qText, ans}) => {
  const lines = qText.split('\n').filter(l => l.trim() !== '');
  let q = null, list = [];
  lines.forEach(line => {
    if (/^\d+\./.test(line)) {
      if (q) list.push(q);
      q = { question: line.replace(/^\d+\.\s*/, ""), options: [] };
    } else if (/^[A-D]\)/.test(line)) {
      q.options.push(line.replace(/^[A-D]\)\s*/, ""));
    }
  });
  if (q) list.push(q);
  questions = list.map((q, i) => ({
    question: q.question,
    options: q.options,
    correct: ans[i+1].map(x => x.charCodeAt(0) - 65)
  }));
  renderQuestions();
  setTimeout(setupCanvas, 800);
});

function renderQuestions() {
  const container = document.getElementById("questions-container");
  container.innerHTML = "";
  questions.forEach((q, qi) => {
    const box = document.createElement("div");
    box.className = "question-box";
    box.style.display = qi === 0 ? "block" : "none";
    box.innerHTML = `<h5 class="mb-3">Question ${qi+1}</h5><p class="fs-5">${q.question}</p><ul class="options mt-3 list-unstyled"></ul>`;
    const ul = box.querySelector(".options");
    q.options.forEach((opt, oi) => {
      const li = document.createElement("li");
      li.innerHTML = `<label class="option-label"><input type="radio" name="q-${qi}"><span class="fw-bold me-2">${String.fromCharCode(65+oi)})</span> ${opt}</label>`;
      li.querySelector("input").addEventListener("change", () => handleAnswer(qi, oi, li.querySelector(".option-label")));
      ul.appendChild(li);
    });
    container.appendChild(box);
  });
}

function handleAnswer(qi, oi, label) {
  const correct = questions[qi].correct.includes(oi);
  document.querySelectorAll(`input[name="q-${qi}"]`).forEach(r => r.disabled = true);
  if (correct) {
    label.style.background = "#d4edda";
    label.style.borderColor = "#28a745";
    score++;
    showNotification("Correct!", "correct");
  } else {
    label.style.background = "#f8d7da";
    label.style.borderColor = "#dc3545";
    showNotification("Incorrect", "incorrect");
  }
  document.getElementById("score-banner").innerText = `Score: ${score}`;
}

function showQuestion(i) {
  const boxes = document.querySelectorAll(".question-box");
  boxes.forEach((box, idx) => box.style.display = idx === i ? "block" : "none');
  currentQuestionIndex = i;
}

function nextQuestion() { if (currentQuestionIndex < questions.length - 1) showQuestion(currentQuestionIndex + 1); }
function prevQuestion() { if (currentQuestionIndex > 0) showQuestion(currentQuestionIndex - 1); }

function showNotification(msg, cls) {
  const n = document.getElementById("notification");
  n.innerText = msg; n.className = cls; n.style.display = "block";
  setTimeout(() => n.style.display = "none", 1000);
}

window.addEventListener('resize', setupCanvas);
</script>
</body>
</html>
